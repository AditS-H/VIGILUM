// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title ProofOfExploit
 * @notice Contract for submitting and verifying exploit proofs
 * @dev Stores exploit evidence and tracks verifications
 */

// Forward declare interfaces
interface IVigilumRegistryExploit {
    function blacklistContract(address contractAddr, string calldata reason) external;
}

interface IRedTeamDAOExploit {
    function recordExploit(
        address targetContract,
        string calldata description,
        uint256 severity,
        uint256 bountyAmount
    ) external returns (bytes32);
}

contract ProofOfExploit {
    /// @notice Exploit proof structure
    struct Proof {
        bytes32 id;
        address submitter;
        address targetContract;
        uint256 severity; // 1-5
        string description;
        bytes proofData; // Encrypted or hashed proof
        uint256 submittedAt;
        bool verified;
        bool rewardClaimed;
        uint256 rewardAmount;
    }

    /// @notice Verification structure
    struct Verification {
        address verifier;
        bool approved;
        string notes;
        uint256 verifiedAt;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // STATE VARIABLES
    // ═══════════════════════════════════════════════════════════════════════════

    address public owner;
    address public vigilumRegistry;
    address public redTeamDAO;

    mapping(bytes32 => Proof) public proofs;
    mapping(bytes32 => Verification[]) public verifications;
    mapping(bytes32 => mapping(address => bool)) public hasVerified;

    bytes32[] public proofIds;
    uint256 public proofCount = 0;

    // Configuration
    uint256 public constant MIN_VERIFICATION_COUNT = 3;
    uint256 public constant VERIFICATION_TIMEOUT = 14 days;
    mapping(uint256 => uint256) public severityRewards; // severity -> reward in wei

    // ═══════════════════════════════════════════════════════════════════════════
    // EVENTS
    // ═══════════════════════════════════════════════════════════════════════════

    event ProofSubmitted(bytes32 indexed proofId, address indexed submitter, address targetContract, uint256 severity);
    event ProofVerified(bytes32 indexed proofId, address indexed verifier, bool approved);
    event ProofConfirmed(bytes32 indexed proofId, bool approved);
    event RewardClaimed(bytes32 indexed proofId, address indexed submitter, uint256 amount);
    event ContractBlacklisted(address indexed contractAddr, bytes32 indexed proofId);

    // ═══════════════════════════════════════════════════════════════════════════
    // CONSTRUCTOR
    // ═══════════════════════════════════════════════════════════════════════════

    constructor(address _vigilumRegistry, address _redTeamDAO) {
        owner = msg.sender;
        vigilumRegistry = _vigilumRegistry;
        redTeamDAO = _redTeamDAO;

        // Set default rewards for each severity level
        severityRewards[1] = 0.5 ether;  // Low
        severityRewards[2] = 1 ether;    // Medium
        severityRewards[3] = 2.5 ether;  // High
        severityRewards[4] = 5 ether;    // Critical
        severityRewards[5] = 10 ether;   // Severe
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // PROOF SUBMISSION
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Submit an exploit proof
     * @param targetContract Address of vulnerable contract
     * @param severity Severity level (1-5)
     * @param description Exploit description
     * @param proofData Encrypted/hashed proof data
     * @return proofId Unique proof identifier
     */
    function submitProof(
        address targetContract,
        uint256 severity,
        string calldata description,
        bytes calldata proofData
    ) external returns (bytes32) {
        require(severity >= 1 && severity <= 5, "Invalid severity");
        require(targetContract != address(0), "Invalid target");
        require(proofData.length > 0, "Proof data required");
        require(bytes(description).length > 0, "Description required");

        bytes32 proofId = keccak256(
            abi.encodePacked(msg.sender, targetContract, block.timestamp, proofData)
        );

        require(proofs[proofId].submittedAt == 0, "Proof already exists");

        Proof storage proof = proofs[proofId];
        proof.id = proofId;
        proof.submitter = msg.sender;
        proof.targetContract = targetContract;
        proof.severity = severity;
        proof.description = description;
        proof.proofData = proofData;
        proof.submittedAt = block.timestamp;
        proof.verified = false;
        proof.rewardClaimed = false;
        proof.rewardAmount = severityRewards[severity];

        proofIds.push(proofId);
        proofCount++;

        // Record in DAO
        if (redTeamDAO != address(0)) {
            IRedTeamDAOExploit(redTeamDAO).recordExploit(
                targetContract,
                description,
                severity,
                proof.rewardAmount
            );
        }

        emit ProofSubmitted(proofId, msg.sender, targetContract, severity);
        return proofId;
    }

    /**
     * @notice Get proof details
     */
    function getProof(bytes32 proofId) external view returns (
        address submitter,
        address targetContract,
        uint256 severity,
        string memory description,
        uint256 submittedAt,
        bool verified,
        uint256 rewardAmount
    ) {
        Proof storage proof = proofs[proofId];
        require(proof.submittedAt != 0, "Proof not found");

        return (
            proof.submitter,
            proof.targetContract,
            proof.severity,
            proof.description,
            proof.submittedAt,
            proof.verified,
            proof.rewardAmount
        );
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // VERIFICATION
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Verify a submitted proof
     * @param proofId ID of proof to verify
     * @param approved True if proof is valid
     * @param notes Verification notes
     */
    function verifyProof(
        bytes32 proofId,
        bool approved,
        string calldata notes
    ) external onlyVerifier {
        Proof storage proof = proofs[proofId];
        require(proof.submittedAt != 0, "Proof not found");
        require(!proof.verified, "Already verified");
        require(!hasVerified[proofId][msg.sender], "Already voted");
        require(
            block.timestamp < proof.submittedAt + VERIFICATION_TIMEOUT,
            "Verification period expired"
        );

        hasVerified[proofId][msg.sender] = true;

        verifications[proofId].push(Verification({
            verifier: msg.sender,
            approved: approved,
            notes: notes,
            verifiedAt: block.timestamp
        }));

        emit ProofVerified(proofId, msg.sender, approved);

        // Check if consensus reached
        if (verifications[proofId].length >= MIN_VERIFICATION_COUNT) {
            _finalizeVerification(proofId);
        }
    }

    /**
     * @notice Finalize verification once enough votes collected
     */
    function _finalizeVerification(bytes32 proofId) internal {
        Proof storage proof = proofs[proofId];
        Verification[] storage votes = verifications[proofId];

        uint256 approvalCount = 0;
        for (uint256 i = 0; i < votes.length; i++) {
            if (votes[i].approved) {
                approvalCount++;
            }
        }

        bool approved = approvalCount > votes.length / 2;

        proof.verified = true;

        if (approved) {
            // Blacklist contract
            if (vigilumRegistry != address(0)) {
                IVigilumRegistryExploit(vigilumRegistry).blacklistContract(
                    proof.targetContract,
                    proof.description
                );
            }
        }

        emit ProofConfirmed(proofId, approved);
    }

    /**
     * @notice Get verifications for a proof
     */
    function getVerifications(bytes32 proofId) external view returns (
        address[] memory verifiers,
        bool[] memory approvals,
        uint256[] memory timestamps
    ) {
        Verification[] storage votes = verifications[proofId];
        verifiers = new address[](votes.length);
        approvals = new bool[](votes.length);
        timestamps = new uint256[](votes.length);

        for (uint256 i = 0; i < votes.length; i++) {
            verifiers[i] = votes[i].verifier;
            approvals[i] = votes[i].approved;
            timestamps[i] = votes[i].verifiedAt;
        }

        return (verifiers, approvals, timestamps);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // REWARDS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Claim reward for verified proof
     */
    function claimReward(bytes32 proofId) external {
        Proof storage proof = proofs[proofId];
        require(proof.submittedAt != 0, "Proof not found");
        require(proof.verified, "Proof not verified");
        require(!proof.rewardClaimed, "Reward already claimed");
        require(msg.sender == proof.submitter, "Not submitter");

        // Check if approved
        uint256 approvalCount = 0;
        for (uint256 i = 0; i < verifications[proofId].length; i++) {
            if (verifications[proofId][i].approved) {
                approvalCount++;
            }
        }
        require(
            approvalCount > verifications[proofId].length / 2,
            "Proof not approved"
        );

        proof.rewardClaimed = true;

        // Transfer reward (would need contract to receive funds)
        // In practice, this would use a treasury or escrow contract
        emit RewardClaimed(proofId, msg.sender, proof.rewardAmount);
    }

    /**
     * @notice Set reward amount for severity level
     */
    function setReward(uint256 severity, uint256 amount) external onlyOwner {
        require(severity >= 1 && severity <= 5, "Invalid severity");
        severityRewards[severity] = amount;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // STATISTICS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * @notice Get statistics for a target contract
     */
    function getContractStats(address targetContract) external view returns (
        uint256 totalProofs,
        uint256 verifiedProofs,
        uint256[] memory severityCounts
    ) {
        uint256 total = 0;
        uint256 verified = 0;
        uint256[] memory counts = new uint256[](5);

        for (uint256 i = 0; i < proofIds.length; i++) {
            if (proofs[proofIds[i]].targetContract == targetContract) {
                total++;
                if (proofs[proofIds[i]].verified) {
                    verified++;
                }
                counts[proofs[proofIds[i]].severity - 1]++;
            }
        }

        return (total, verified, counts);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // MODIFIERS
    // ═══════════════════════════════════════════════════════════════════════════

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyVerifier() {
        // In production, this would check a verifier registry
        require(msg.sender != address(0), "Not verifier");
        _;
    }
}
